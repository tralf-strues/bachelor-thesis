\section{Введение}
% Как таковое, понятие «игровой движок» появилось в середине 90-х годов прошлого века с выходом \textit{Doom Engine} в 1995 году. Данный продукт заложил основные идеи выявления ключевых переиспользуемых модулей, независимых от конкретной игры, с целью ускорить итерационность разработки новых игр. Первые такие движки были спроектированы для конкретных жанров, или даже конкретной игровой серии (как в случае с \textit{Doom Engine}). Однако за последние несколько десятилетий концепция игрового движка сильно преобразовалась. Ключевым изменением стало стремление к созданию движков, позволяющих создавать игры произвольных жанров и c разнообразными художественными стилями. Данная тенденция к созданию слоев абстракций не является уникальной для индустрии видеоигр и может наблюдаться во всех сферах разработки. Отличием же игровых движков от большинства других программных продуктов является необходимость хорошей производительности в реальном времени, что ограничивает разработчиков в абстрагировании различных частей движка, заставляя идти на компромисс между общностью, удобством и производительностью.

% Современные игровые движки должны поддерживать разные виды устройств, операционные системы и зачастую немалый диапазон аппаратного обеспечения. Добавив к этому большое количество подсистем, инструментов, а также возможность написания игр произвольных стилей и жанров, получится огромная комбинаторная сложность. Именно из-за этого написание нового игрового движка в современном мире довольно комплексная задача, требующая немалого количества специалистов, много времени и бюджета. Это привело к тому, что крупные движки вынуждены вводить комиссии для разработчиков за каждую проданную копию игры. В последние годы из-за чрезмерной комплексности движков и тяжелой комиссионной политики, разработчики игр стали задумываться о переходе на относительно новые движки с открытым исходным кодом, что особенно распространяется на некрупные игровые студии, которые не в состоянии отдавать большой процент от продаж и нанимать высококвалифицированных разработчиков, способных модифицировать крупные движки под проектные нужды.

% С ростом производительности аппаратного обеспечения, появлением новых технологий и непрерывным увеличением масштабов современных игровых проектов архитектурные паттерны проектирования движков потерпели значимые изменения и развитие. Однако ввиду комплексности, о которой было упомянуто ранее, крупные движки неспособны быстро реализовывать новые подходы, а в некоторых случаях не в состоянии реализовать их вообще, ведь они могут потребовать полного перепланирования всего движка.

% Целью данной работы таким образом является исследование современных подходов к архитектуре игровых движков, а также базовая имплементация некоторых из них.

% Рендеринг реального времени значительно изменился за последние несколько десятилетий благодаря достижениям в аппаратных возможностях и программных решениях. Отрисовка современных видеоигр состоит из большого количества вычислений, которые еще недавно казались недостижимыми в интерактивных приложениях. С ростом комплексности рендеринга и особенно с появлением современных графических программных интерфейсов, таких как Vulkan, Directx 12 и Metal, в индустрии появилась необходимость в новом архитектурном решении декомпозиции рендеринга. Одним из таких решений являются кадровые графы.

% Кадровый граф является одним из способов организации работы на GPU и представляет из себя ориентированный ациклический граф, где вершины являются вычислительными задачами, а ребра между ними задают зависимости в порядке исполнения. Декомпозиция рендеринга на отдельные единицы исполнения упрощает процесс разработки новых графических эффектов, а полный граф дает глобальное представление о процессе отрисовки одного кадра (или же части кадра), что часто полезно при анализе производительности и отладке приложений. Важно заметить, что кадровые графы являются не только архитектурным решением структурирования рендеринга, но и мощным инструментом оптимизации. Обладание полной картиной кадра еще до момента исполнения позволяет (автоматически) утилизировать современные функции графических API, таких как, например, использование нескольких командных очередей, многопоточная запись командных буферов и др.


% \subsection{Базовые определения}
% Провести границу между понятиями «видеоигра» и «игровой движок» не всегда можно однозначно, и для каждого конкретного случая она будет разной. Однако для конструктивного анализа важно все же зафиксировать четкое разграничение между этими понятиями. Важно заметить, что в виду специфики данной работы дальше приводятся определения с инженерной точки зрения.

% Прежде всего, \textit{видеоигра}, или же просто \textit{игра}, как программный продукт, представляет собой синергетическое сочетание содержательной части (контента) и логической части (программной логики), создающее интерактивную виртуальную среду.

% Под \textit{игровым движком} понимается комплекс программных модулей, обеспечивающий реализацию основных функций игры, таких как графика, организация игрового мира, работа с ресурсами, физика, звук, работа с сетью и т.д. Он представляет собой набор библиотек, который позволяет разработчикам создавать игры различных жанров и уровней комплексности для потенциально нескольких платформ. Игровые движки значительно упрощают и ускоряют процесс разработки, предоставляя готовые решения для многих задач. Однако важно заметить, что видеоигры не обязаны разрабатываться на основе какого-либо игрового движка.

% Наконец, \textit{игровой редактор}, или просто \textit{редактор} -- программа с графическим интерфейсом, предоставляющая возможность создавать контент игры, утилизируя игровой движок. Это программное обеспечение позволяет разработчикам и дизайнерам реализовывать творческие идеи, не погружаясь полностью в технические детали реализации движка. Оптимальный дизайн игрового редактора способствует повышению эффективности разработки игр и сокращению времени, необходимого для воплощения итеративных изменений в игровых проектах. Часто под движком понимают именно редактор, однако с инженерной точки зрения, это принципиально разные понятия, особенно, если рассматривать движки, в принципе не имеющие редактора.



% % \subsection{Высокоуровневый обзор модулей}
% Существует принципиально две различные компоненты движка -- программный комплекс исполнения (\textit{engine runtime}) и набор инструментов разработки (\textit{tool suit}), второе часто представляет из себя в совокупности игровой редактор.

% % \subsubsection{Инструменты разработки/редактор}
% Набор инструментов разработки -- инструменты для создании и модификации контента игры. Эти инструменты предоставляют разработчикам интерфейсы и функции для работы с различными аспектами игры, включая графику, звук, анимацию и игровой процесс. Чаще всего эти инструменты являются частью игрового редактора. Примерами инструментов могут послужить:

% \begin{itemize}
%     \item \textit{Редактор уровней} позволяет дизайнерам создавать и редактировать игровые уровни, размещать объекты и настраивать игровые события.
%     \item \textit{UI редактор} используется для разработки и настройки элементов внутриигрового пользовательского интерфейса.
%     \item \textit{Редактор ассетов} используется для импорта, настройки и управления различными видами игрового контента.
%     \item \textit{Инструменты анимации} обеспечивают создание и настройку анимаций для персонажей и объектов.
%     \item \textit{Инструменты сборки} позволяют собирать финальный игровой продукт для целевых платформ.
% \end{itemize}

% % \subsubsection{Модули исполнения}
% Программный комплекс исполнения (или ядро движка) отвечает за запуск и функционирование игры в режиме реального времени. Модули исполнения обрабатывают ввод, обновляют игровую логику, рендеринг мира, воспроизведение звука и многое другое. Именно эта часть игрового движка рассматривается в данной работе.

% Как и в большинстве больших программных систем, движок можно разделить на несколько слоев, где более высокоуровневые слои используют низкоуровневые.



% \subsection{Разбор существующих решений}

% \subsubsection{Крупные универсальные движки}
% \subsubsection{Проприетарные движки}

% \subsection{Мотивация}
Рендеринг реального времени значительно изменился за последние несколько десятилетий благодаря достижениям в аппаратных возможностях и программных решениях. Отрисовка современных видеоигр включает большой объем вычислений, который еще недавно казался недостижимыми в интерактивных приложениях. С ростом сложности рендеринга и с появлением современных графических интерфейсов, таких как Vulkan, DirectX 12 и Metal, возникла необходимость в новых архитектурных решениях для декомпозиции рендеринга. Одним из таких решений является кадровый граф.

Кадровый граф представляет собой способ организации работы на GPU, представляя собой ориентированный ациклический граф, в котором вершины — это вычислительные задачи, а ребра между ними задают зависимости в порядке исполнения. Декомпозиция рендеринга на отдельные единицы исполнения упрощает процесс разработки новых графических эффектов, а полный граф дает глобальное представление о процессе отрисовки одного кадра (или его части), что особенно полезно при анализе производительности и отладке приложений. Важно отметить, что кадровые графы служат не только архитектурным решением для структурирования рендеринга, но и мощным инструментом оптимизации. Обладая полной картиной кадра до момента исполнения, можно эффективно использовать современные функции графических API, такие как, например, использование нескольких командных очередей \cite{vulkan_command_queues} и многопоточная запись командных буферов \cite{vulkan_command_buffers}. Это позволяет автоматизировать и упростить процесс рендеринга, при этом повышая производительность приложений. Именно поэтому внедрение кадровых графов в процесс рендеринга является важным шагом в развитии технологий реального времени, обеспечивая более гибкие и мощные инструменты для разработчиков.

В данной работе рассматривается связь между кадровыми графами и Render Hardware Interface (дальше сокращенно RHI), представляющим собой слой абстракции, который инкапсулирует низкоуровневые детали взаимодействия с различными графическими API. Его основная задача - предоставить унифицированный программный интерфейс для отправки команд рендеринга на GPU, независимо от используемого графического API и/или аппаратной конфигурации. Благодаря абстракции низкоуровневых деталей, движок может быть легко портирован на различные платформы, требуя лишь реализации RHI для новой целевой платформы. Использование RHI также означает, что достаточно разработать всего один высокоуровневый рендерер. Поскольку современные игровые движки должны предоставлять немалое количество графических эффектов, без RHI разработчики были бы не в состоянии быстро реализовывать сразу несколько версий этих эффектов под каждый интерфейс.

\subsection{Обзор существующих решений}
Первым широко известным описанием кадровых графов был доклад Юрия О’Доннелла об архитектуре рендеринга в проприетарном игровом движке Frostbite \cite{frame_graph_frostbite} в 2017 году. Их кадровый граф был разработан для решения проблем комплексности и взаимосвязанности в предыдущей архитектуре рендерера, а также в целях сокращения утилизации видеопамяти, с помощью переиспользования памяти для ресурсов, не использующихся одновременно, что особенно критично для консолей. Кадровый граф в Frostbite полностью задавался программно, а задачи связывались с помощью глобального типизированного хранилища -- blackboard. Важно также отметить, что кадровый граф был глобальным и единственным на кадр. Представленное в этом докладе решение положило основу современным имплементациям кадровых графов.

В игровом движке Unreal Engine 5 также присутствует кадровый граф, который называется Render Dependency Graph \cite{render_dependency_graph_ue5}. Данная имплементация очень похожа на решение в Frostbite, однако есть и несколько отличий -- возможность создания нескольких графов и возможность автоматической декларации использования ресурсов в шейдерах при помощи препроцессинга полей структур в исходном коде.

Стремление к упрощению и более неявной декларации кадровых графов послужило главной мотивацией библиотеки, разработанной компанией AMD \cite{amd_rps_sdk}. Ключевым отличием от других решений является то, что с данной библиотекой граф создается внутри собственного шейдерного языка -- RPSL, а потом внутри кода программы можно подключать функции к заданным в данных вершинам. Однако важно уточнить, что библиотека поддерживает разные фронтенды, и программная декларация все еще возможна при работе с данным решением.

\begin{table}[ht]
    \centering
    \begin{tabular}{ p{56mm} | p{30mm} | p{30mm} | p{30mm} }
      & Frostbite & Unreal Engine 5 & AMD RPS \\
    \hline
    Immediate или Retained Mode & Immediate & Immediate & Retained \\
    \hline
    Тип декларации & Программная & Программная & В данных или программная \\
    \hline
    Возможное количество графов & Один & Несколько & Несколько \\
    \hline
    Связь с RHI & Поверх & Поверх & Поверх \\
    \end{tabular}
    \caption{Сравнение рассмотренных решений}
    \label{tbl:comparison_analysis}
  \end{table}

\subsection{Цели работы}
При анализе существующих решений было обнаружено, что все они реализуют кадровые графы поверх RHI. В целом, такой подход логичен с точки зрения распределения человеческих ресурсов. Необходимо написать несколько имплементаций RHI (под каждый необходимый графический API), а после этого одну имплементацию кадрового графа, используя интерфейс RHI. В данной работе представлено альтернативное решение -- сделать кадровые графы непосредственно частью RHI. Такое решение позволит утилизировать напрямую уникальные возможности каждого графического API и потенциально избавит от необходимости пытаться обобщить дизайн работы с командами, то есть абстракции над командными буферами, очередями и примитивами синхронизации. Таким образом целями данной работы являются:
\begin{enumerate}
    \item Проектирование дизайна кадрового графа, встроенного напрямую в RHI.
    \item Имплементация данного дизайна, используя современный графический API -- Vulkan.
    \item Внедрение и реализация высокоуровнего рендерера для подтверждения валидности дизайна.
\end{enumerate}
% внедрение кадрового графа в RHI, имплементация данного дизайна на основе одного из современных графических API (Vulkan), а также проектирование и реализация высокоуровнего рендерера для подтверждения валидности дизайна.
